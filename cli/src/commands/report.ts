import chalk from 'chalk';
import fs from 'fs';
import path from 'path';
import { ConfigService } from '@/services/ConfigService';
import { UsageService } from '@/services/UsageService';
import { formatCurrency, formatDate } from '@/utils/format';
import { CommandOptions } from '@/types';

export async function reportCommand(options: CommandOptions) {
  const configService = new ConfigService();
  const usageService = new UsageService();

  try {
    console.log(chalk.cyan('ğŸ“Š Generating Cost Report\n'));

    const usage = await usageService.getCurrentUsage();
    const config = configService.getConfig();
    const budget = config.budget;

    let reportContent = '';
    const reportDate = new Date().toISOString().split('T')[0];

    switch (options.format) {
      case 'markdown':
        reportContent = generateMarkdownReport(usage, config, budget, reportDate, options.period);
        break;
      case 'csv':
        reportContent = generateCSVReport(usage, config, reportDate, options.period);
        break;
      default:
        reportContent = generateJSONReport(usage, config, budget, reportDate, options.period);
    }

    if (options.output) {
      const outputPath = path.resolve(options.output);
      fs.writeFileSync(outputPath, reportContent);
      console.log(chalk.green(`âœ… Report saved to ${outputPath}`));
    } else {
      console.log(reportContent);
    }

  } catch (error) {
    console.error(chalk.red('âŒ Error generating report:'), error);
    process.exit(1);
  }
}

function generateJSONReport(usage: any, config: any, budget: any, date: string, period: string): string {
  return JSON.stringify({
    reportDate: date,
    period,
    currency: config.currency,
    summary: {
      today: usage.today,
      thisWeek: usage.thisWeek,
      thisMonth: usage.thisMonth,
      projected: usage.projected,
      budget: budget.monthly,
      budgetUsed: usage.budgetUsed
    },
    topModels: usage.topModels,
    dailyTrend: usage.dailyTrend,
    budget: budget
  }, null, 2);
}

function generateMarkdownReport(usage: any, config: any, budget: any, date: string, period?: string): string {
  return `# API Cost Report

**Report Date:** ${date}  
**Period:** ${period}  
**Currency:** ${config.currency}

## Summary

| Metric | Amount |
|--------|--------|
| Today | ${formatCurrency(usage.today, config.currency)} |
| This Week | ${formatCurrency(usage.thisWeek, config.currency)} |
| This Month | ${formatCurrency(usage.thisMonth, config.currency)} |
| Projected Monthly | ${formatCurrency(usage.projected, config.currency)} |
| Budget | ${formatCurrency(budget.monthly, config.currency)} |
| Budget Used | ${usage.budgetUsed.toFixed(1)}% |

## Top Models

| Model | Usage | Cost | Percentage |
|-------|-------|------|------------|
${usage.topModels.map((model: any) => 
  `| ${model.model} | ${model.usage} | ${formatCurrency(model.cost, config.currency)} | ${model.percentage.toFixed(1)}% |`
).join('\n')}

## Recommendations

- Consider optimizing usage of high-cost models
- Set up alerts for budget monitoring
- Review usage patterns for optimization opportunities

---
*Generated by API Cost Guard*`;
}

function generateCSVReport(usage: any, config: any, date: string, period?: string): string {
  const headers = 'Date,Cost,Tokens,Requests\n';
  const dailyData = usage.dailyTrend.map((day: any) => 
    `${day.date},${day.cost},${day.tokens},${day.requests}`
  ).join('\n');
  
  return headers + dailyData;
}